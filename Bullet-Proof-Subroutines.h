#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S2, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S3, HTServo,  none,     none,     none)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     rf,            tmotorTetrix, openLoop, driveLeft, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     rb,            tmotorTetrix, openLoop, driveLeft)
#pragma config(Motor,  mtr_S1_C2_1,     lf,            tmotorTetrix, openLoop, reversed, driveRight)
#pragma config(Motor,  mtr_S1_C2_2,     lb,            tmotorTetrix, openLoop, driveRight, encoder)
#pragma config(Motor,  mtr_S2_C1_1,     fl,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C1_2,     fr,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_1,     ul,            tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S2_C2_2,     ur,            tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S3_C1_1,    s1,                   tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    servo2,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S3_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "hitechnic-irseeker-v2.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-gyro.h"
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#define CLICKS_PER_REVOLUTION  1120
#define DISTANCE_PER_CLICK  (WHEEL_CIRCUMFERENCE/CLICKS_PER_REVOLUTION)
#define DISTANCE_FOR_TURN  2700
#define DISTANCE_FOR_SWING_TURN  2700
#define LEFT 	     1
#define RIGHT	    -1
#define SWING_TURN_LEFT  1
#define SWING_TURN_RIGHT  0
#define DEGREES_90   1
#define DEGREES_80  0.9
#define DEGREES_45   0.5
#define DEGREES_70  0.8
#define DEGREES_36   0.4
#define DEGREES_20   0.22
#define DEGREES_25   0.25
#define DEGREES_170  0.85
#define DEGREES_135  1.33
#define DEGREES_10  0.11
#define DEGREES_15  0.15
#define DEGREES_110  1.22
#define DEGREES_105  1.15
#define DEGREES_100  1.11
#define LEFT_SIDE_DRIVE    0
#define RIGHT_SIDE_DRIVE   1
#define RIGHT_SIDE_LIFT  3
#define LEFT_SIDE_LIFT  2
#define DEGREES_180  2
#define DEGREES_360  4
#define LATCH_DOWN 100
#define LATCH_UP 140
#define LIFT_MOTOR_SPEED 100
#define DOOR_OPEN  0
#define DOOR_CLOSED  225
#define SWEEPER_ON -35
#define SWEEPER_OFF 0
#define LIFT_120_HEIGHT  18700
#define LIGHT_DOWN_LEFT  255
#define LIGHT_UP_LEFT  30
#define LIGHT_DOWN_RIGHT  0
#define LIGHT_UP_RIGHT  225
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int liftmotor = 0;
float powerratio = 1; // "powerratio" is used to decrease speed in drive train to go up ramps and slow down as needed via joystick.
int leftmotorpower;
int rightmotorpower;
int sweeperpower;
bool complete = false;
int CurrentTime;
int SweeperStopTime;
float LiftSpeedLimit;
int LatchPosition;
int ServoPosition;
int oldval;
int _dirAC = 0;
int MotorEncoder;
int IrReading1;
int IrReading2;
int IrReading3;
int IrReading4;
int IrReading5;
bool stickAtRamp;
bool stickAtZone;
//float WHEEL_CIRCUMFERENCE = (3.875 * PI);
float WHEEL_CIRCUMFERENCE = (4 * PI);
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void IrSetup(){
	tHTIRS2DSPMode _mode = DSP_1200;  // the default DSP mode is 1200 Hz.
	while (true){
		// set the DSP to the new mode
		if (HTIRS2setDSPMode(HTIRS2, _mode))
			break; // Sensor initialized
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LightSensorLower(){
	servo[leftlight] = LIGHT_DOWN_LEFT;
	servo[rightlight] = LIGHT_DOWN_RIGHT;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void LightSensorLift(){
	servo[leftlight] = LIGHT_UP_LEFT;
	servo[rightlight] = LIGHT_UP_RIGHT;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void TubeLatch(int ServoPosition){
	servo[latch] = ServoPosition;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void ScoreBallInTube(int ServoPosition){
	servo[door] = ServoPosition;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void watchdog(int oldval){
	wait1Msec(100);
	if (oldval == nMotorEncoder[rf]){
		writeDebugStreamLine("Right Motor Encoder Value = %f, Left Motor Encoder Value = %f",nMotorEncoder[ur],nMotorEncoder[ul]);
		writeDebugStreamLine("Motors stopped due to watchdog");
		stopAllTasks();
	}
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ReadIR(){
	_dirAC = HTIRS2readACDir(HTIRS2);
	writeDebugStreamLine("_dirAC = %i",_dirAC);
	return _dirAC;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EncoderResetDrive(){
	nMotorEncoder[rf] = 0;
	nMotorEncoder[lf] = 0;
	wait1Msec(50);
	writeDebugStreamLine("right drive encoder = %i, left drive encoder = %i",nMotorEncoder[rf],nMotorEncoder[lf]);
	wait1Msec(50);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void EncoderResetLift(){
	nMotorEncoder[ur] = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void StopDriveMotors(){
	motor[lf] = 0;
	motor[lb] = 0;
	motor[rf] = 0;
	motor[rb] = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void StopLiftMotors(){
	motor[ul] = 0;
	motor[ur] = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int ReadMotorEncoder(int encoderNumber){
	//wait1Msec(50);
	switch(encoderNumber){
	//case 0: MotorEncoder = nMotorEncoder[lf];writeDebugStreamLine("Left Drive Motor Encoder Value = %f",MotorEncoder);break;
	//case 1: MotorEncoder = nMotorEncoder[rf];writeDebugStreamLine("Right Drive Motor Encoder Value = %f",MotorEncoder);break;
	//case 2: MotorEncoder = nMotorEncoder[ul];writeDebugStreamLine("Left Lift Motor Encoder Value = %f",MotorEncoder);break;
	//case 3: MotorEncoder = nMotorEncoder[ur];writeDebugStreamLine("Right Lift Motor Encoder Value = %f",MotorEncoder);break;
	case 0: MotorEncoder = nMotorEncoder[lb];break;
	case 1: MotorEncoder = nMotorEncoder[rf];break;
	case 2: MotorEncoder = nMotorEncoder[ul];break;
	case 3: MotorEncoder = nMotorEncoder[ur];break;
}
	return MotorEncoder;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void lift(int height, int MotorSpeed){
	float goal;
	goal = (((height/2.54) / (2* PI))* (3/1.3))* CLICKS_PER_REVOLUTION;    //Converts height from cm to in, divides by spool circumference, multiplies
                                                                         // by gear ratio, then by amount of clicks per one motor revolution.
	writeDebugStreamLine("Entering lift height=%i, goal=%f",height,goal);
	wait1Msec(50);
	motor[ur] = MotorSpeed;
	motor[ul] = MotorSpeed;
	writeDebugStreamLine("Set lift speed");
	while(((abs(ReadMotorEncoder(RIGHT_SIDE_LIFT)) < (goal - 2000)) && ((abs(ReadMotorEncoder(RIGHT_SIDE_LIFT)) < LIFT_120_HEIGHT) && (MotorSpeed > 0)) ||
	  (abs(ReadMotorEncoder(RIGHT_SIDE_LIFT)) > 300) && (MotorSpeed < 0))){
		writeDebugStreamLine("Lifting up at 100% power");
		writeDebugStreamLine("Left lift encoder = %f, right lift encoder = %f",nMotorEncoder[ul]);
	}
	writeDebugStreamLine("Went up at 100% power");
	if (MotorSpeed > 0){                                                   //When going back down, no need to slow down motors
		motor[ur] = MotorSpeed*0.4;
		motor[ul] = MotorSpeed*0.4;
		writeDebugStreamLine("Starting lift at slower speed");
		while((abs(ReadMotorEncoder(RIGHT_SIDE_LIFT)) < (goal - 150)) && ((abs(ReadMotorEncoder(RIGHT_SIDE_LIFT)) < LIFT_120_HEIGHT))){
			writeDebugStreamLine("Lifting up at lower power");
		}
	}
	StopLiftMotors();
	writeDebugStreamLine("Leaving Lift Program");
	writeDebugStreamLine("Left Lift Motor Encoder Value = %f, Right Lift Motor Encoder Value = %f",nMotorEncoder[ul],nMotorEncoder[ur]);
	ReadMotorEncoder(RIGHT_SIDE_LIFT);ReadMotorEncoder(LEFT_SIDE_LIFT);
	wait1Msec(50);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void GoForward(float inches, float speed){
	float goal;
	goal = (CLICKS_PER_REVOLUTION/WHEEL_CIRCUMFERENCE)*inches;
	writeDebugStreamLine("Entering GoForward inches=%f, speed=%f, goal=%f",inches,speed,goal,);
	EncoderResetDrive();
	wait1Msec(50);
		motor[lf] = speed;
		motor[lb] = speed;
		motor[rf] = speed;
		motor[rb] = speed;
	while(abs(ReadMotorEncoder(RIGHT_SIDE_DRIVE)) < goal){
		//writeDebugStreamLine("Left Drive Motor Encoder Value = %f",nMotorEncoder[lf]);
	}
	StopDriveMotors();                                                  // uses the stop function to set motors to 0
	writeDebugStreamLine("Leaving GoForward Program");
	writeDebugStreamLine("Left Drive Motor Encoder Value = %f, Right Drive Motor Encoder Value = %f",nMotorEncoder[lf],nMotorEncoder[rf]);
	wait1Msec(50);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void turn(int direction, float percentof90, float speed){
	float goal = DISTANCE_FOR_TURN *percentof90;
	writeDebugStreamLine("Entering Turn direction=%i, percentof90=%f, speed=%f, goal=%f",direction,percentof90,speed,goal);
	EncoderResetDrive();
	wait1Msec(50);
		motor[lf] = -speed* direction;
		motor[lb] = -speed* direction;
		motor[rf] = speed* direction;
		motor[rb] = speed* direction;
	while(abs(ReadMotorEncoder(RIGHT_SIDE_DRIVE)) < goal){
	}
	StopDriveMotors();
	ReadMotorEncoder(RIGHT_SIDE_DRIVE);ReadMotorEncoder(LEFT_SIDE_DRIVE);
	writeDebugStreamLine("Leaving Turn Program");
	StopDriveMotors();                                                      // uses the stop function to set motors to 0
	wait1Msec(50);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void SwingTurn(int direction, float percentof90, float speed){
	float goal = DISTANCE_FOR_SWING_TURN *percentof90;
	float turnSpeedLeft;
	float turnSpeedRight;
	turnSpeedLeft = speed/ (direction ? -1.4 : 1);
	turnSpeedRight = speed/ (direction ? 1 : -1.4);
	writeDebugStreamLine("Entering SwingTurn direction=%i, percentof90=%f, speed=%f, goal=%f",direction,percentof90,speed,goal);
	writeDebugStreamLine("Left motor speed = %i, Right motor speed = %i",turnSpeedLeft,turnSpeedRight);
	EncoderResetDrive();
	wait1Msec(50);
	motor[lf] = turnSpeedLeft; //If direction = 1(left), right side motors = 100% power, left side motors = 25% power
	motor[lb] = turnSpeedLeft;//If direction = 0(right), right side motors = 25% power, left side motors = 100% power
	motor[rf] = turnSpeedRight;
	motor[rb] = turnSpeedRight;
	while((abs(ReadMotorEncoder(RIGHT_SIDE_DRIVE)) < goal) && (abs(ReadMotorEncoder(LEFT_SIDE_DRIVE)) < goal)){
		//"abs" is used if one value is negative(going backwards as long as both drive sides are less than the goal, robot will turn
	}
	StopDriveMotors(); // uses the stop function to set motors to 0
	writeDebugStreamLine("Leaving Turn Program");
	writeDebugStreamLine("Right Drive Encoder = %f, Left Drive Encoder = %f,",nMotorEncoder[rf],nMotorEncoder[lf]);
	wait1Msec(50);
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void sweeperInitialize(){
	motor[fl] = 75;
	motor[fr] = 75;
	wait1Msec(100);
	motor[fl] = SWEEPER_OFF;
	motor[fr] = SWEEPER_OFF;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot(){
	clearDebugStream();
	//LightSensorLift();
	servo[latch] = LATCH_UP;
	servo[door] = DOOR_CLOSED;
	EncoderResetLift();
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobotTeleop(){
	clearDebugStream();
	//LightSensorLift();
	servo [latch] = LATCH_UP;
	servo[door] = DOOR_CLOSED;
	sweeperInitialize();
	EncoderResetLift();
	CurrentTime = 0;
}
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*void ScoreBallIn120(){
	writeDebugStreamLine("Start ScoreIn120 Routine");
	GoForward(20,20);
	LightSensorLower();
	GoForward(30,-15);
	if(SensorValue(leftlight) && SensorValue(rightlight)){
	StopDriveMotors();
	GoForward(6,-10);
	lift(115,LIFT_MOTOR_SPEED);
	ScoreBallInTube(DOOR_OPEN);
	wait1Msec(500);
	ScoreBallInTube(DOOR_CLOSED);
	lift(115,-LIFT_MOTOR_SPEED);
	IrSetup();
	if (ReadIR()!= 3){
	Zone1();//Stick facing parking zone
	stopAllTasks();
	}
	else{
	GoForward(27,25);
	}
	if (ReadIR() == 3){
	Zone2();//Stick facing diagonal to zone
	stopAllTasks();
	}
	else{
	Zone3();//Stick facing ramp
	stopAllTasks();
	}
	*/
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
